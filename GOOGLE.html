<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>KML / KMZ Viewer â€“ Advanced Buffer</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet.polylinemeasure/Leaflet.PolylineMeasure.css">

<style>
html,body,#map{height:100%;margin:0;}

#panel{
  position:absolute;
  top:10px; left:10px;
  z-index:1000;
  background:#fff;
  padding:10px;
  width:280px;
  font-family:Arial;
  box-shadow:0 0 10px rgba(0,0,0,.4);
}

.kml-label{
  color:#fff;
  font-weight:bold;
  text-shadow:2px 2px 4px #000;
  pointer-events:none;
  white-space:nowrap;
  font-size:12px;
}

input,button{width:100%;margin-top:4px;}
</style>
</head>

<body>

<div id="panel">
  <input type="file" id="fileInput" accept=".kml,.kmz" multiple>

  <hr>
  <button onclick="toggleLabels()">Text ON / OFF</button>

  <hr>
  <b>Geometry</b><br>
  <input type="checkbox" id="ptChk" checked> Points<br>
  <input type="checkbox" id="lnChk" checked> Lines<br>
  <input type="checkbox" id="pgChk" checked> Polygons

  <hr>
  <b>ðŸŸ  Buffer Tool</b>
  <input type="number" id="bufDist" value="20">
  <input type="color" id="bufColor" value="#00ffff">
  <label>Opacity: <span id="bufValue">0.3</span></label>
  <input type="range" id="bufOpacity" min="0" max="1" step="0.1" value="0.3">

  <b>Buffer Area:</b>
  <div id="bufArea">0 sqm</div>

  <button onclick="createBuffer()">Generate Buffer</button>
  <button onclick="clearBuffer()">Clear Buffer</button>
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
<script src="https://unpkg.com/@tmcw/togeojson@5.6.0/dist/togeojson.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/leaflet.polylinemeasure/Leaflet.PolylineMeasure.min.js"></script>

<script>
// ================= MAP =================
const satellite=L.tileLayer(
 "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
 {maxZoom:22}
);

const map=L.map("map",{
  center:[22,78],
  zoom:4,
  layers:[satellite],
  zoomControl:false,
  preferCanvas:true
});

L.control.polylineMeasure({position:"topright"}).addTo(map);

// ================= GLOBAL =================
const pointGroup=L.layerGroup().addTo(map);
const lineGroup=L.layerGroup().addTo(map);
const polyGroup=L.layerGroup().addTo(map);
const bufferGroup=L.layerGroup().addTo(map);

const labels=[];
let visibleLabels=[];
let selectedFeatures=[];
let labelsVisible=false;
let currentZoom=null;  // TRACK CURRENT ZOOM FOR TEXT PERSISTENCE

const POINT_ZOOM=14;
const LABEL_ZOOM=15;

// ================= SAFE FIT =================
function safeFitBounds(layer){
  let b=L.latLngBounds([]);
  layer.eachLayer(l=>{
    if(l.getLatLng) b.extend(l.getLatLng());
    else if(l.getBounds) b.extend(l.getBounds());
  });
  if(b.isValid()){
    map.fitBounds(b,{padding:[40,40]});
    if(map.getZoom()>=LABEL_ZOOM) map.setZoom(LABEL_ZOOM-1);
  }
}

// ================= FILE LOAD =================
fileInput.onchange=e=>{
  [...e.target.files].forEach(f=>{
    if(f.name.endsWith(".kml")) loadKML(f);
    if(f.name.endsWith(".kmz")) loadKMZ(f);
  });
};

function loadKML(file){
  const r=new FileReader();
  r.onload=()=>addGeo(
    toGeoJSON.kml(new DOMParser().parseFromString(r.result,"text/xml"))
  );
  r.readAsText(file);
}

function loadKMZ(file){
  JSZip.loadAsync(file).then(zip=>{
    zip.forEach((p,e)=>{
      if(p.endsWith(".kml")){
        e.async("string").then(t=>{
          addGeo(toGeoJSON.kml(
            new DOMParser().parseFromString(t,"text/xml")
          ));
        });
      }
    });
  });
}

// ================= ADD DATA =================
function addGeo(gj){
  const layer=L.geoJSON(gj,{
    style:f=>{
      if(f.geometry.type.includes("Polygon"))
        return{color:"red",fillOpacity:.3};
      if(f.geometry.type.includes("Line"))
        return{color:"yellow",weight:3};
    },

    pointToLayer:(f,ll)=>{
      const m=L.circleMarker(ll,{
        radius:5,
        color:"#ffffff",
        weight:1.5,
        fillColor:"#2ea8ff",
        fillOpacity:0.9
      });
      pointGroup.addLayer(m);
      return m;
    },

    onEachFeature:(f,l)=>{
      if(l instanceof L.Polygon) polyGroup.addLayer(l);
      if(l instanceof L.Polyline) lineGroup.addLayer(l);

      l.on("click",()=>{
        if(selectedFeatures.includes(l)){
          selectedFeatures=selectedFeatures.filter(x=>x!==l);
          l.setStyle?.({color:l instanceof L.Polygon?"red":"yellow"});
        }else{
          selectedFeatures.push(l);
          l.setStyle?.({color:"#00ff00"});
        }
      });

      if(f.properties?.name){
        labels.push(
          L.marker(
            l.getBounds?.()?.getCenter?.()||l.getLatLng(),
            {icon:L.divIcon({className:"kml-label",html:f.properties.name})}
          )
        );
      }
    }
  }).addTo(map);

  setTimeout(()=>safeFitBounds(layer),100);
  refreshVisibility();
}

// ================= SMART LABEL ENGINE =================
function updateLabels(){
  visibleLabels.forEach(l=>map.removeLayer(l));
  visibleLabels=[];

  if(!labelsVisible) return;

  const bounds=map.getBounds();
  const taken=[];

  for(const lbl of labels){
    if(!bounds.contains(lbl.getLatLng())) continue;

    map.addLayer(lbl);
    const el=lbl.getElement();
    if(!el) continue;

    const r=el.getBoundingClientRect();
    const overlap=taken.some(t=>
      !(r.right<t.left || r.left>t.right || r.bottom<t.top || r.top>t.bottom)
    );

    if(overlap){
      map.removeLayer(lbl);
    }else{
      taken.push(r);
      visibleLabels.push(lbl);
    }
  }
}

// ================= VISIBILITY =================
function refreshVisibility(){
  const z=map.getZoom();

  // Points / Lines / Polygons visibility
  z>=POINT_ZOOM && ptChk.checked
    ? map.addLayer(pointGroup)
    : map.removeLayer(pointGroup);

  lnChk.checked?map.addLayer(lineGroup):map.removeLayer(lineGroup);
  pgChk.checked?map.addLayer(polyGroup):map.removeLayer(polyGroup);

  // Labels smart engine
  if(z !== currentZoom){
    currentZoom=z;      // update zoom
    labelsVisible=false; // reset text ON for new zoom
  }

  if(labelsVisible && z>=LABEL_ZOOM){
    setTimeout(updateLabels,60);
  }else{
    visibleLabels.forEach(l=>map.removeLayer(l));
    visibleLabels=[];
  }
}

map.on("zoomend",refreshVisibility);
map.on("moveend",refreshVisibility);
ptChk.onchange=refreshVisibility;
lnChk.onchange=refreshVisibility;
pgChk.onchange=refreshVisibility;

// Toggle labels
function toggleLabels(){
  if(map.getZoom() >= LABEL_ZOOM){
    labelsVisible=true;  // ON for current zoom
    refreshVisibility();
  }
}

// ================= BUFFER =================
bufOpacity.oninput=()=>bufValue.innerText=bufOpacity.value;

function createBuffer(){
  bufferGroup.clearLayers();
  let totalArea=0;

  const dist=Number(bufDist.value)/1000;
  const targets=selectedFeatures.length
    ? selectedFeatures
    : [...pointGroup.getLayers(),...lineGroup.getLayers(),...polyGroup.getLayers()];

  targets.forEach(l=>{
    const buf=turf.buffer(l.toGeoJSON(),dist,{units:"kilometers"});
    totalArea+=turf.area(buf);

    L.geoJSON(buf,{
      style:{
        color:bufColor.value,
        weight:2,
        fillOpacity:Number(bufOpacity.value)
      }
    }).addTo(bufferGroup);
  });

  bufArea.innerText=totalArea.toFixed(2)+" sqm";
}

function clearBuffer(){
  bufferGroup.clearLayers();
  selectedFeatures=[];
  bufArea.innerText="0 sqm";
}
</script>

</body>
</html>
