<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>KML / KMZ Viewer â€“ Stable</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">

<style>
html,body,#map{
  height:100%;
  margin:0;
}

#panel{
  position:absolute;
  top:10px;
  left:10px;
  z-index:1000;
  background:#fff;
  padding:10px;
  width:280px;
  font-family:Arial;
  box-shadow:0 0 10px rgba(0,0,0,.4);
}

#layerList div{ margin-top:5px; }

/* ðŸ”¤ LABEL STYLE */
.kml-label{
  color:#ffffff;
  font-weight:bold;
  white-space:nowrap;
  text-shadow:2px 2px 4px #000;
  pointer-events:none;
}

#searchBox{
  width:100%;
  margin-bottom:5px;
}
</style>
</head>

<body>

<div id="panel">
  <input type="file" id="fileInput" accept=".kml,.kmz" multiple><br><br>
  
  <input type="text" id="searchBox" placeholder="Search feature name">
  <button onclick="searchFeature()">Search</button><br><br>

  <button onclick="toggleLabels()">Text ON / OFF</button>
  <hr>

  <b>Geometry</b><br>
  <input type="checkbox" id="ptChk" checked> Points<br>
  <input type="checkbox" id="lnChk" checked> Lines<br>
  <input type="checkbox" id="pgChk" checked> Polygons

  <hr>
  <b>Files</b>
  <div id="layerList"></div>
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
<script src="https://unpkg.com/@tmcw/togeojson@5.6.0/dist/togeojson.umd.js"></script>

<script>
// ================= MAP =================
const satellite = L.tileLayer(
 "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
 { maxZoom:22, maxNativeZoom:19 }
);

const map = L.map("map",{
  center:[22,78],
  zoom:4,
  zoomControl:false,
  layers:[satellite]
});

L.control.zoom({position:"topright"}).addTo(map);

// ================= GLOBAL =================
const layers = {};
const labels = {};
let labelsVisible = true;
const LABEL_MIN_ZOOM = 11;

// Geometry groups
const pointGroup = L.layerGroup().addTo(map);
const lineGroup  = L.layerGroup().addTo(map);
const polyGroup  = L.layerGroup().addTo(map);

// ================= FILE INPUT =================
document.getElementById("fileInput").addEventListener("change", e=>{
  for(const file of e.target.files){
    if(file.name.toLowerCase().endsWith(".kml")) loadKML(file);
    if(file.name.toLowerCase().endsWith(".kmz")) loadKMZ(file);
  }
});

// ================= LOADERS =================
function loadKML(file){
  const r=new FileReader();
  r.onload=()=>{
    const kml=new DOMParser().parseFromString(r.result,"text/xml");
    addLayer(toGeoJSON.kml(kml),file.name);
  };
  r.readAsText(file);
}

function loadKMZ(file){
  JSZip.loadAsync(file).then(zip=>{
    zip.forEach((p,e)=>{
      if(p.toLowerCase().endsWith(".kml")){
        e.async("string").then(t=>{
          const kml=new DOMParser().parseFromString(t,"text/xml");
          addLayer(toGeoJSON.kml(kml),file.name);
        });
      }
    });
  });
}

// ================= ADD LAYER =================
function addLayer(geojson,name){

  const fileGroup=L.layerGroup().addTo(map);
  layers[name]=fileGroup;
  labels[name]=[];

  let featureBounds = [];

  L.geoJSON(geojson,{
    style: function(f){
      if(f.geometry.type==="Polygon" || f.geometry.type==="MultiPolygon"){
        return {color:"#e31a1c",weight:2,fillColor:"#e31a1c",fillOpacity:0.4};
      } else if(f.geometry.type==="LineString" || f.geometry.type==="MultiLineString"){
        return {color:"#33a02c",weight:3};
      }
      return {color:"#0000ff"}; // default
    },

    pointToLayer:(f,ll)=>{
      const m=L.circleMarker(ll,{radius:5,color:"#1f78b4",fillColor:"#1f78b4",fillOpacity:1});
      pointGroup.addLayer(m);
      fileGroup.addLayer(m);
      featureBounds.push(m.getLatLng());
      return m;
    },

    onEachFeature:(f,layer)=>{
      if(layer instanceof L.Polygon){
        polyGroup.addLayer(layer);
        fileGroup.addLayer(layer);
      } else if(layer instanceof L.Polyline){
        lineGroup.addLayer(layer);
        fileGroup.addLayer(layer);
      }

      const pos =
        layer.getBounds?.()?.getCenter?.() ||
        layer.getLatLng?.();

      if(pos) featureBounds.push(pos);

      if(f.properties?.name){
        const label=L.marker(pos,{
          icon:L.divIcon({className:"kml-label",html:f.properties.name,iconSize:[200,24]})
        });
        labels[name].push(label);
        if(labelsVisible && map.getZoom()>=LABEL_MIN_ZOOM) label.addTo(map);
      }
    }
  });

  // Auto zoom to file features
  if(featureBounds.length>0){
    const bounds = L.latLngBounds(featureBounds);
    map.fitBounds(bounds,{padding:[40,40]});
  }

  // ---- FILE TOGGLE UI ----
  const row=document.createElement("div");
  row.innerHTML=`<input type="checkbox" checked> ${name}`;
  row.querySelector("input").onchange=function(){
    if(this.checked){
      map.addLayer(fileGroup);
      refreshLabels();
    } else {
      map.removeLayer(fileGroup);
      labels[name].forEach(l=>map.removeLayer(l));
    }
  };
  document.getElementById("layerList").appendChild(row);

  refreshLabels();
}

// ================= GEOMETRY TOGGLE =================
ptChk.onchange=()=> toggleGroup(pointGroup,ptChk.checked);
lnChk.onchange=()=> toggleGroup(lineGroup,lnChk.checked);
pgChk.onchange=()=> toggleGroup(polyGroup,pgChk.checked);

function toggleGroup(group,on){
  if(on) map.addLayer(group);
  else map.removeLayer(group);
  refreshLabels();
}

// ================= LABEL DECLUTTER =================
function refreshLabels(){

  const zoom=map.getZoom();
  const drawn=[];

  for(const k in labels){
    labels[k].forEach(l=>map.removeLayer(l));
  }

  if(!labelsVisible || zoom<LABEL_MIN_ZOOM) return;

  for(const k in labels){
    if(!map.hasLayer(layers[k])) continue;

    labels[k].forEach(l=>{
      const p=map.latLngToContainerPoint(l.getLatLng());
      const box={x:p.x-60,y:p.y-12,w:120,h:24};

      if(drawn.some(b=>intersect(b,box))) return;

      map.addLayer(l);
      drawn.push(box);
    });
  }
}

function intersect(a,b){
  return !(b.x>a.x+a.w || b.x+b.w<a.x || b.y>a.y+a.h || b.y+b.h<a.y);
}

map.on("zoomend moveend",refreshLabels);

// ================= LABEL TOGGLE =================
function toggleLabels(){
  labelsVisible=!labelsVisible;
  refreshLabels();
}

// ================= SEARCH =================
function searchFeature(){
  const query=document.getElementById("searchBox").value.toLowerCase();
  if(!query) return;

  let found=false;
  for(const name in labels){
    for(const lbl of labels[name]){
      const text = lbl.getElement()?.innerText?.toLowerCase();
      if(text && text.includes(query)){
        const latlng = lbl.getLatLng();
        map.setView(latlng,16);
        lbl.openPopup?.();
        found=true;
        return;
      }
    }
  }
  if(!found) alert("Feature not found!");
}
</script>

</body>
</html>
